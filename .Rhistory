# Entrega: 2
# Fecha:
##---------------------------------------------------------------------------
# Tiempo dedicado a la entrega:
# Dificultades encontradas y manera de resolverlas:
##---------------------------------------------------------------------------
# 1. AsegÃƒÂºrese de incluir, junto a esta plantilla, cualquier fichero necesario
#    para su ejecuciÃƒÂ³n, incluidos datasets
# 2. Si utiliza una funciÃƒÂ³n de un determinado paquete, no olvide incluir la
#    correspondiente llamada a la funciÃƒÂ³n "library()"
# 3. No olvide comentar el cÃƒÂ³digo, en especial aquellos comandos no-triviales
#    (recuerda que parte de la calificaciÃƒÂ³n depende de la limpieza del cÃƒÂ³digo)
#---------------------------------------------------------------------------.
rm(list = ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
library(frbs)
library(ggplot2)
# (incluya aquÃƒ­ cualquier librerÃƒ­a adicional)
library(tidyverse)
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
######################## Parte 1 ###########################################
#--------------------------------------------------------------------------.
# Descarge y lea los datos que puede encontrar en el siguiente link:
# https://www.kaggle.com/jacobbaruch/basketball-players-stats-per-season-49-leagues
# Lea los datos en R
datos = read.csv("datos/players_stats_by_season_full_details.csv")
resultados = datos %>% select(Player,Season,weight_kg,height_cm)
# AÃƒÂ±ada una columna llamada altocrisp con valores 0 o 1 (numÃƒÂ©ricos) segÃƒÂºn si la
# altura del juegador es menor o mayor que 190cm
resultados$altocrisp = ifelse(resultados$height_cm>190,1,0)
# Defina, como un vector de 4 elementos un conjunto difuso llamado alto
# (como considere deberÃƒ­a ser)
# --> alto = c(..., ..., ..., ...)
alto = c(190,210,230,2300)
# Cree una funciÃƒÂ³n llamada trapMF que reciba un nÃƒÂºmero y un conjunto difuso y
# devuelva el valor de pertenencia del nÃƒÂºmero al conjunto definido
# --> trapMF = function(valor,conjunto){....}
trapMF= function(valor, conjunto){
ifelse(between(valor,conjunto[1], conjunto[2]),((valor-conjunto[1])/(conjunto[2]-conjunto[1])),
ifelse(between(valor,conjunto[2], conjunto[3]),1,
ifelse(between(valor,conjunto[3], conjunto[4]),((conjunto[4]-valor)/(conjunto[4]-conjunto[3])),0)))
}
# AÃƒÂ±ada una columna llamada altofuzzy, resultado de aplicar la funciÃƒÂ³n trapMF sobre los elementos de la columna height y el conjunto alto
# --> nombredeldataframe$altofuzzy = apply(data.frame(nombredeldataframe$height), 1, FUN=function(x) trapMF(x,alto))
resultados$altofuzzy = apply(data.frame(resultados$height_cm), 1, FUN=function(x) trapMF(x,alto))
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altocrisp
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altofuzzy
# En ambos casos, utilize el valor de altura para colorear los puntos
# --> Utilize la librerÃƒ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=altocrisp))+geom_point()
ggplot(resultados,aes(x=height_cm,y=altofuzzy))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 2 ###########################################
#--------------------------------------------------------------------------.
# De la misma manera que en la primera parte, cree un conjunto llamado "pesado",
# para el peso de un jugador
# --> pesado = c(..., ..., ..., ...)
pesado = c(95,120,180,180)
# AÃƒÂ±ada una columna llamada pesadofuzzy, resultado de aplicar la funciÃƒÂ³n trapMF sobre los elementos de la columna points_per_minute y el conjunto bueno
# --> nombredeldataframe$pesadofuzzy = apply(..., 1, FUN=function(x) trapMF(x,pesado))
resultados$pesadofuzzy = apply(data.frame(resultados$weight_kg),1,function(x) trapMF(x,pesado))
# Genere una columna llamada altoypesado resultado de la tnorma mÃƒ­nimo sobre las columnas altofuzzy y pesadofuzzy
# --> nombredeldataframe$altoypesado = ...
resultados$altoypesado = apply(data.frame(resultados$altofuzzy, resultados$pesadofuzzy), 1, max)
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X, su peso en el eje Y, y utilize para dar color el valor de la columna altoypesado, generada
# --> Utilize la librerÃƒ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=weight_kg,color=altoypesado))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 3 ###########################################
#--------------------------------------------------------------------------.
# Implemente un sistema difuso que dÃƒÂ© una valoraciÃƒÂ³n entre 0 y 100 de los jugadores de baloncesto
# a partir de las caracterÃƒ­sticas del fichero de datos
# Criterio de valoraciÃƒÂ³n libre
# Requisitos bÃƒÂ¡sicos
# Utilizar al menos 2 de las variables y codificar cada una de ellas con al menos 3 conjuntos difusos
# Incluir al menos 5 reglas difusas
# AÃƒÂ±ada el resultado de la ejecuciÃƒÂ³n del sistema como una nueva columna a los datos y genere un dibujo
# Pista1: En la ayuda de la funciÃƒÂ³n "frbs.gen" tenÃƒÂ©is un ejemplo de creaciÃƒÂ³n de un sistema difuso
# Pista2: Os dejo aquÃƒ­ un desglose de los pasos a dar, con alguna indicaciÃƒÂ³n
# Consejo: explore la posibilidad de crear nuevas columnas en funciÃƒÂ³n de los datos numÃƒÂ©ricos que hay en la tabla
#  - % de acierto de 3 puntos
#  - Puntos/partido
#  - Minutos jugados/partido
#  (...)
#Cambio los NA por 0 para evitar problemas en la parte 3 a la hora de hacer el sistema
#True Shooting Percentage
tsp = function(PTS,FGA,FTA){
return (PTS/(2*(FGA+(0.44*FTA)))*100)
}
datos$TSP = apply(data.frame(datos$PTS, datos$FGA, datos$FTA), 1,function(x) tsp(x[1],x[2],x[3]))
prueba = datos %>%
filter(TSP > 100) %>%
select(FGA, FTA, PTS)
#Minutes per game
mpg = function(MIN,GP){
return (MIN/GP)
}
datos$MPG = apply(data.frame(datos$MIN, datos$GP), 1, function(x) mpg(x[1],x[2]))
# Paso 1, definir todos los conjuntos difusos a usar como vectores de 5 elementos
# --> etiqueta1 = c(valor,xxx, xxx, xxx, xxx)
# *nota, valor serÃƒÂ¡ 2, 3, 4, dependiendo si es una etiqueta "izquierda"(2), "central"(4), o "derecha"(3)
# *para etiquetas "izquierdas", c(2,b,c,d,NA)
# *para etiquetas "centrales", c(4,a,b,c,d)
# *para etiquetas "derechas", c(3,a,b,c,NA)
# *a,b,c,d representan los puntos de una etiqueta trapezoidal
#Conjuntos difusos TSP
TSPBajo = c(2,0,30,40,NA)
TSPMedio = c(4,30,40,56,75)
TSPALTO = c(3,56,75,100,NA)
#Conjuntos difusos MPG
MPGBajo = c(2,0,10,20,NA)
MPGMedio = c(4,10,20,25,30)
MPGAlto = c(3,25,30,40,NA)
# Paso 2, pegar todas las etiquetas por columnas y asignar a una variable
# --> varinp.mf = cbind(etiqueta1,etiqueta2,etiqueta3...)
varinp.mf = cbind(TSPBajo,TSPMedio,TSPALTO,MPGBajo,MPGMedio,MPGAlto)
# Paso 3, definir una matriz con el nÃƒÂºmero de etiquetas de cada entrada
# --> num.fvalinput = matrix(c(numeroetiquetasentrada1,numeroetiquetasentrada2), nrow=1)
num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
#REVISAR!!!!!!!!!!!!!!!!!! De 0 a 100 auqnue no sea maximo real
range.data <- matrix(c(0,100, 0, 200, 0, 100), nrow=2)
# Paso 6, defina el tipo de defuzificaciÃƒÂ³n, tnorma y tconorma, e implicaciÃƒÂ³n, asÃƒ­ como el tipo de modelo
# --> type.defuz = "COG"
# --> type.tnorm = "MIN"
# --> type.snorm = "MAX"
# --> type.implication.func = "MIN"
# --> type.model <- "MAMDANI"
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
# Paso 7, cree una variable "newdata" ÃƒÂºnicamente con las columnas que utilizarÃƒÂ¡ su sistema
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = data.frame(datos$TSP, datos$MPG)
newdata[is.na(newdata)] = 0
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
# Paso 9, defina los nombres de las etiquetas de salida y sus funciones, de la misma manera que en los pasos 1,2,3,4
#num.fvaloutput = matrix(c(5), nrow = 1)
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
#rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
#                    "Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
#                    "Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio",
#                    "Tirador medio", "and", "Poco tiempo jugado","->", "Jugador de bajo nivel",
#                   "Mal tirador", "and", "Poco tiempo jugado","->", "Mal jugador"),
#                  nrow = 5, byrow = TRUE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
range.data <- matrix(c(0,200, 0, 48, 0, 100), nrow=2)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
PTS =15
FGA =5
FTA =5
num1 = (PTS/(2*(FGA+(0.5*FTA)))*100)
num1
tsp = function(PTS,FGA,FTA){
return (PTS/(2*(FGA+(0.5*FTA)))*100)
}
datos$TSP = apply(data.frame(datos$PTS, datos$FGA, datos$FTA), 1,function(x) tsp(x[1],x[2],x[3]))
prueba = datos %>%
filter(TSP > 100) %>%
select(FGA, FTA, PTS)
PTS =15
FGA =5
FTA =5
num1 = (PTS/(2*(FGA+(0.33*FTA)))*100)
num1
PTS =15
FGA =5
FTA =5
num1 = (PTS/(2*(FGA+(0.6*FTA)))*100)
num1
tsp = function(PTS,FGA,FTA){
return (PTS/(2*(FGA+(0.6*FTA)))*100)
}
datos$TSP = apply(data.frame(datos$PTS, datos$FGA, datos$FTA), 1,function(x) tsp(x[1],x[2],x[3]))
prueba = datos %>%
filter(TSP > 100) %>%
select(FGA, FTA, PTS)
View(num.fvaloutput)
View(prueba)
PTS =106
FGA =25
FTA =7
num1 = (PTS/(2*(FGA+(0.6*FTA)))*100)
num1
PTS =106
FGA =25
FTA =7
num1 = (PTS/(2*(FGA+(0*FTA)))*100)
num1
PTS =106
FGA =25
FTA =7
num1 = (PTS/(2*(FGA+(0.65*FTA)))*100)
num1
PTS =106
FGA =25
FTA =7
num1 = (PTS/(2*(FGA+(1*FTA)))*100)
num1
PTS =106
FGA =25
FTA =7
num1 = (PTS/(2*(FGA+(.47*FTA)))*100)
num1
# Nombre: Egoitz Aranzabal Calvo
# Entrega: 2
# Fecha:
##---------------------------------------------------------------------------
# Tiempo dedicado a la entrega:
# Dificultades encontradas y manera de resolverlas:
##---------------------------------------------------------------------------
# 1. AsegÃƒÂºrese de incluir, junto a esta plantilla, cualquier fichero necesario
#    para su ejecuciÃƒÂ³n, incluidos datasets
# 2. Si utiliza una funciÃƒÂ³n de un determinado paquete, no olvide incluir la
#    correspondiente llamada a la funciÃƒÂ³n "library()"
# 3. No olvide comentar el cÃƒÂ³digo, en especial aquellos comandos no-triviales
#    (recuerda que parte de la calificaciÃƒÂ³n depende de la limpieza del cÃƒÂ³digo)
#---------------------------------------------------------------------------.
rm(list = ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
library(frbs)
library(ggplot2)
# (incluya aquÃƒ­ cualquier librerÃƒ­a adicional)
library(tidyverse)
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
######################## Parte 1 ###########################################
#--------------------------------------------------------------------------.
# Descarge y lea los datos que puede encontrar en el siguiente link:
# https://www.kaggle.com/jacobbaruch/basketball-players-stats-per-season-49-leagues
# Lea los datos en R
datos = read.csv("datos/players_stats_by_season_full_details.csv")
resultados = datos %>% select(Player,Season,weight_kg,height_cm)
# AÃƒÂ±ada una columna llamada altocrisp con valores 0 o 1 (numÃƒÂ©ricos) segÃƒÂºn si la
# altura del juegador es menor o mayor que 190cm
resultados$altocrisp = ifelse(resultados$height_cm>190,1,0)
# Defina, como un vector de 4 elementos un conjunto difuso llamado alto
# (como considere deberÃƒ­a ser)
# --> alto = c(..., ..., ..., ...)
alto = c(190,210,230,2300)
# Cree una funciÃƒÂ³n llamada trapMF que reciba un nÃƒÂºmero y un conjunto difuso y
# devuelva el valor de pertenencia del nÃƒÂºmero al conjunto definido
# --> trapMF = function(valor,conjunto){....}
trapMF= function(valor, conjunto){
ifelse(between(valor,conjunto[1], conjunto[2]),((valor-conjunto[1])/(conjunto[2]-conjunto[1])),
ifelse(between(valor,conjunto[2], conjunto[3]),1,
ifelse(between(valor,conjunto[3], conjunto[4]),((conjunto[4]-valor)/(conjunto[4]-conjunto[3])),0)))
}
# AÃƒÂ±ada una columna llamada altofuzzy, resultado de aplicar la funciÃƒÂ³n trapMF sobre los elementos de la columna height y el conjunto alto
# --> nombredeldataframe$altofuzzy = apply(data.frame(nombredeldataframe$height), 1, FUN=function(x) trapMF(x,alto))
resultados$altofuzzy = apply(data.frame(resultados$height_cm), 1, FUN=function(x) trapMF(x,alto))
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altocrisp
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altofuzzy
# En ambos casos, utilize el valor de altura para colorear los puntos
# --> Utilize la librerÃƒ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=altocrisp))+geom_point()
ggplot(resultados,aes(x=height_cm,y=altofuzzy))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 2 ###########################################
#--------------------------------------------------------------------------.
# De la misma manera que en la primera parte, cree un conjunto llamado "pesado",
# para el peso de un jugador
# --> pesado = c(..., ..., ..., ...)
pesado = c(95,120,180,180)
# AÃƒÂ±ada una columna llamada pesadofuzzy, resultado de aplicar la funciÃƒÂ³n trapMF sobre los elementos de la columna points_per_minute y el conjunto bueno
# --> nombredeldataframe$pesadofuzzy = apply(..., 1, FUN=function(x) trapMF(x,pesado))
resultados$pesadofuzzy = apply(data.frame(resultados$weight_kg),1,function(x) trapMF(x,pesado))
# Genere una columna llamada altoypesado resultado de la tnorma mÃƒ­nimo sobre las columnas altofuzzy y pesadofuzzy
# --> nombredeldataframe$altoypesado = ...
resultados$altoypesado = apply(data.frame(resultados$altofuzzy, resultados$pesadofuzzy), 1, max)
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X, su peso en el eje Y, y utilize para dar color el valor de la columna altoypesado, generada
# --> Utilize la librerÃƒ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=weight_kg,color=altoypesado))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 3 ###########################################
#--------------------------------------------------------------------------.
# Implemente un sistema difuso que dÃƒÂ© una valoraciÃƒÂ³n entre 0 y 100 de los jugadores de baloncesto
# a partir de las caracterÃƒ­sticas del fichero de datos
# Criterio de valoraciÃƒÂ³n libre
# Requisitos bÃƒÂ¡sicos
# Utilizar al menos 2 de las variables y codificar cada una de ellas con al menos 3 conjuntos difusos
# Incluir al menos 5 reglas difusas
# AÃƒÂ±ada el resultado de la ejecuciÃƒÂ³n del sistema como una nueva columna a los datos y genere un dibujo
# Pista1: En la ayuda de la funciÃƒÂ³n "frbs.gen" tenÃƒÂ©is un ejemplo de creaciÃƒÂ³n de un sistema difuso
# Pista2: Os dejo aquÃƒ­ un desglose de los pasos a dar, con alguna indicaciÃƒÂ³n
# Consejo: explore la posibilidad de crear nuevas columnas en funciÃƒÂ³n de los datos numÃƒÂ©ricos que hay en la tabla
#  - % de acierto de 3 puntos
#  - Puntos/partido
#  - Minutos jugados/partido
#  (...)
#True Shooting Percentage
FGP = function(FGM,FGA){
return (FGM/FGA)*100
}
datos$FGP = apply(data.frame(datos$FGM, datos$FGA), 1,function(x) tsp(x[1],x[2],x[3]))
datos$FGP = apply(data.frame(datos$FGM, datos$FGA), 1,function(x) tsp(x[1],x[2]))
datos$FGP = apply(data.frame(datos$FGM, datos$FGA), 1,function(x) FGP(x[1],x[2]))
FGP = function(FGM,FGA){
return ((FGM/FGA)*100)
}
datos$FGP = apply(data.frame(datos$FGM, datos$FGA), 1,function(x) FGP(x[1],x[2]))
#Minutes per game
mpg = function(MIN,GP){
return (MIN/GP)
}
datos$MPG = apply(data.frame(datos$MIN, datos$GP), 1, function(x) mpg(x[1],x[2]))
#Conjuntos difusos TSP
TSPBajo = c(2,0,30,40,NA)
TSPMedio = c(4,30,40,56,75)
TSPALTO = c(3,56,75,100,NA)
#Conjuntos difusos MPG
MPGBajo = c(2,0,10,20,NA)
MPGMedio = c(4,10,20,25,30)
MPGAlto = c(3,25,30,40,NA)
# Paso 2, pegar todas las etiquetas por columnas y asignar a una variable
# --> varinp.mf = cbind(etiqueta1,etiqueta2,etiqueta3...)
varinp.mf = cbind(TSPBajo,TSPMedio,TSPALTO,MPGBajo,MPGMedio,MPGAlto)
# Paso 3, definir una matriz con el nÃƒÂºmero de etiquetas de cada entrada
# --> num.fvalinput = matrix(c(numeroetiquetasentrada1,numeroetiquetasentrada2), nrow=1)
num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
range.data <- matrix(c(0,100, 0, 48, 0, 100), nrow=2)
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = data.frame(datos$FGP, datos$MPG)
newdata[is.na(newdata)] = 0
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
newdata$calidad = evaluacion
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("FGP", "MPG", "output1")
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
View(newdata)
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
#newdata = data.frame(datos$FGP, datos$MPG)
newdata <- matrix(c(15, 80, 85, 85, 45, 75, 78, 70), nrow = 2, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
range.data <- matrix(c(0,100, 0, 100, 0, 100), nrow=2)
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
#newdata = data.frame(datos$FGP, datos$MPG)
newdata <- matrix(c(15, 80, 85, 85, 45, 75, 78, 70), nrow = 2, byrow = TRUE)
newdata[is.na(newdata)] = 0
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("FGP", "MPG", "output1")
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = data.frame(datos$FGP, datos$MPG)
newdata[is.na(newdata)] = 0
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("FGP", "MPG", "output1")
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃƒÂ³n frbs.gen() para crear el sistema difuso, y la funciÃƒÂ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
newdata$calidad = evaluacion
ggplot(newdata,aes(x=datos.FGP,y=datos.MPG,color=altoypesado))+geom_point()
ggplot(newdata,aes(x=datos.FGP,y=datos.MPG,color=calidad))+geom_point()
