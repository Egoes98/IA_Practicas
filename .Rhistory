# Nombre:
# Entrega:
# Fecha:
##---------------------------------------------------------------------------
# Tiempo dedicado a la entrega:
# Dificultades encontradas y manera de resolverlas:
##---------------------------------------------------------------------------
# 1. AsegÃºrese de incluir, junto a esta plantilla, cualquier fichero necesario
#    para su ejecuciÃ³n, incluidos datasets
# 2. Si utiliza una funciÃ³n de un determinado paquete, no olvide incluir la
#    correspondiente llamada a la funciÃ³n "library()"
# 3. No olvide comentar el cÃ³digo, en especial aquellos comandos no-triviales
#    (recuerda que parte de la calificaciÃ³n depende de la limpieza del cÃ³digo)
#---------------------------------------------------------------------------
rm(list = ls());cat("\014");graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
library(GGally)
library(ggplot2)
library(gridExtra)
# (incluya aquÃ­ cualquier librerÃ­a adicional)
#---------------------------------------------------------------------------
problema = 'datos/bayg29.txt';
puntos = read.table(problema);
long = nrow(puntos);
ggplot(puntos, aes(x = V1, y = V2)) + geom_point() +
geom_label(label = as.character(1:long))
# Paso 1: Crear una matriz llamada distancias, de longxlong elementos. En cada
# posiciÃ³n debe almacenar la distancia entre 2 ciudades
# distancias[i,j] <- distancia euclÃ­dea entre puntos[i,] y puntos[j,]
distancias = matrix(nrow = 29,ncol = 29)
for(i in 1:long){
for(j in 1:long){
distancias[i,j] = sqrt(((puntos[j,1]-puntos[i,1])^2)+((puntos[j,2]-puntos[i,2])^2))
}
}
# Paso 2: Defina la funciÃ³n fitness, que reciba un individuo y la matriz de distancias
# y devuelva la longitud total de los dos caminos recorridos
# --> fitness = function(ind,distancias){...}
fitness = function(ind,distancias){
ruta1 = 0
ruta2 = 0
rutaTotal = 0
zeroPos = match(0,ind)
#En caso de que una ruta tenga solo un punto, o no tenga ninguno devuelve Inf ya qye he decidido que quiero evitar que uno de los caminos no tenga una ruta.
#Al devolver infinito quiero que se pase por alto estos casos concretos
if(length(ind) == 1 || zeroPos == 2 || zeroPos == (length(ind)-1) || zeroPos == 1 || zeroPos == length(ind)){
return(Inf)
}
puntosRuta1 = ind[1:zeroPos-1]
sizePR2 = length(ind)-length(puntosRuta1)-1
puntosRuta2 = ind[zeroPos+1:sizePR2]
for(i in 2:length(puntosRuta1)){
ruta1 = ruta1 + distancias[puntosRuta1[i],puntosRuta1[i-1]]
}
ruta1 = ruta1 + distancias[puntosRuta1[1],puntosRuta1[length(puntosRuta1)]]
for(i in 2:length(puntosRuta2)){
ruta2 = ruta2 + distancias[puntosRuta2[i],puntosRuta2[i-1]]
}
ruta2 = ruta2 + distancias[puntosRuta2[1],puntosRuta2[length(puntosRuta2)]]
rutaTotal = ruta1[1] + ruta2[1]
#He decido que voy a premiar que las rutas tengas, mas o menos los mismos puntos
puntoCentral = as.integer(length(ind)/2)
if(zeroPos == puntoCentral || zeroPos == (puntoCentral+1)){
rutaTotal = rutaTotal - 2000
}
return(rutaTotal)
}
# Paso 3: Defina la funciÃ³n de inicializaciÃ³n, que reciba el nÃºmero de individuos a crear
# y el nÃºmero de puntos (variable long). Ãsta funciÃ³n debe devolver una matriz con tantas
# filas como individuos y "long" columnas.
# En cada fila, habrÃ¡ una permutaciÃ³n (aleatoria) de los valores entre 1 y long
# --> initial = function(number,long){...}
initial = function(number, long){
individuos = matrix(nrow = number, ncol = long+1)
for(i in 1:number){
individuos [i,] = append(sample(1:29,29,replace = FALSE),0,after = sample(1:29,1))
}
individuos
}
# Paso 4: Puede utilizar la funciÃ³n de torneo binario vista en clase
tournamentselection = function(evaluation,number){
indexes = matrix(0,1,length(evaluation))
for (i in 1:length(evaluation)){
a = sample(length(evaluation),size=number)
indexes[i]=a[which.min(evaluation[a])]
}
return(indexes)
}
# Paso 5: Operador de cruce de orden
# Implemente una funciÃ³n que recibe los Ã­ndices de padres, la poblaciÃ³n y la probabilidad de cruce
# y realiza el operador de cruce de orden, como ha visto en clase
# crossover = function(indexparents,population,pcross){
# -->   offspring = population # "Reservar memoria"
# -->     for (i in seq(1,length(indexparents),2)){
# -->       if (runif(1)<pcross){
# -->         ...Realizar el cruce aquÃ­...
# -->       }else{
# -->         ...Pasar a la poblaciÃ³n "offspring" ambos padres
# -->       }
# -->     }
# -->     return(offspring)
# -->   }
crossover = function(indexparents, population,pcross){
offspring = population
for(i in seq(1, length(indexparents),2)){
if(runif(1)<pcross){
cutPoint = sample(1:ncol(population),2,replace = FALSE)
cutPoint = sort(cutPoint,decreasing = FALSE)
cutValues1 = population[i,cutPoint[1]:cutPoint[2]]
cutValues2 = population[i+1,cutPoint[1]:cutPoint[2]]
newOffspring1 = setdiff(population[i+1,],cutValues1)
newOffspring2 = setdiff(population[i,],cutValues2)
newOffspring1 = append(newOffspring1, cutValues1, after = cutPoint[1])
newOffspring2 = append(newOffspring2, cutValues2, after = cutPoint[1])
offspring[i,] = newOffspring1
offspring[i+1,] = newOffspring2
}
}
return(offspring)
}
#cada 2 se ejecuta coges el index parent i y i+1 dices que dos cortar con sample, de cada uno coges y guardas los que vas a quitar. Quitarle a cada uno lo del otro
# Paso 6: Operador de MutaciÃ³n
# Para cada hijo, con probabilidad pmut, intercambiar dos posiciones elegidas aleatoriamente
# -->   mutation = function(population,pmut){...}
mutation = function(population,pmut){
for(i in 1:nrow(population)){
if(runif(1)<pmut){
pos = sample(1:ncol(population),2,replace = FALSE)
value = population[i,pos[1]]
population[i,pos[1]] = population[i,pos[2]]
population[i,pos[2]] = value
}
}
population
}
# Paso 7: Realize hasta 5 pruebas con diferentes configuraciones de los siguientes parÃ¡metros
# analice y comente los resultados a modo de comentarios:
#---------------------------------------------------------------------------
# Prueba1:
# ParÃ¡metros-->
generations = 1000
tournamentsize = 2
probcrossover = 0.9
probmutation  = 0.05
popsize=100
# Resultados-->
# Mejor Individuo
# 24 27  8 21 28  1 10 20 17 22 14 18 15 11 25  0 16 23  7 19  4  6 12  5 26  9 29  3  2 13
# El Fitness
# 10860.5357747789
# JustificaciÃ³n/Razonamiento--> Siendo el primer intennto no tenemos mucho con lo que comparar los resultados todavia, pero podemos
# suponer que al subir las generaciones seremos capaces de bajar el fitness y encontrar un mejor individuo.
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Prueba2:
# ParÃ¡metros-->
generations = 10000
tournamentsize = 2
probcrossover = 0.9
probmutation  = 0.05
popsize=100
# Resultados-->
# Mejor Individuo
# 5  9 12  6 28  1 24  8 27 23 16 15 14 17 18  0 26 29  3  2 20 10 19 25  7 11 22  4 13 21
# El Fitness
# 9826.99190541909
# JustificaciÃ³n/Razonamiento--> Parece que con mas generaciones de ejecucion hemos conseguido bajar la fitness, al tener mas jecucion y hacer mas
# mas mutaciones ha conseguido encontrar un mejor resultado. He runeado 3 veces estos parametros y es cierto que ha habia resultado bastante perores por lo que parece ser que
# la poblacion random que se genera puede resultar clavee para encontrar un resultado bueno con menos generaciones.
#---------------------------------------------------------------------------
generations = 10000
tournamentsize = 2
probcrossover = 0.9
probmutation  = 0.05
popsize=1000
# Paso 8: (para nota) Implemente una funciÃ³n que reciba como argumento el mejor individuo obtenido
# por el algoritmo y las posiciones de los puntos y dibuje las 2 rutas seguidas por los camiones
# Llame a la funciÃ³n al final de la ejecuciÃ³n del algoritmo
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Si todo estÃ¡ bien, el cÃ³digo deberÃ­a funcionar a partir de aquÃ­
# haga las comprobaciones pertienentes para cada operador
# (Si hubiera alguna errata o fallo en el cÃ³digo, que lo puede haber,
# comunÃ­camelo lo antes posible con el fin de solventarlo)
#---------------------------------------------------------------------------
best = c()
bestfitness = Inf
population = initial(popsize,long)
evaluation = apply(population,1,fitness,distancias)
progreso = data.frame(g=numeric(),mejor=numeric(),promedio=numeric(),peor=numeric(),distancia=numeric())
for (g in 1:generations){
indexparents = tournamentselection(evaluation,tournamentsize)
offspring1 = crossover(indexparents,population,probcrossover)
offspring2 = mutation(offspring1,probmutation)
population = offspring2
evaluation = apply(population,1,fitness,distancias)
# Actualizamos el mejor individuo
if (min(evaluation)<bestfitness){
bestfitness=min(evaluation)
best = population[which.min(evaluation),]
}
# Hacemos elitismo
if (bestfitness!=min(evaluation)){
population[1,]=best
}
print(paste("GeneraciÃ³n ",g," Fitness Mejor individuo - ",bestfitness))
print(best)
progreso = rbind(progreso,
data.frame(g=g,mejor=bestfitness,
promedio=mean(evaluation),
peor=max(evaluation),
distancia=mean(as.matrix(dist(population, method = "euclidean")))))
}
# Dibujamos los resultados
plot1 = ggplot(progreso)+
geom_line(aes(x=g,y=mejor),col="green")+
geom_line(aes(x=g,y=promedio),col="blue")+
geom_line(aes(x=g,y=peor),col="red")+
scale_y_log10()+
labs(title = "EvoluciÃ³n de los fitness Mejor, Promedio y Peor",
subtitle = paste("Mejor Individuo Final: ",bestfitness),
caption = "Universidad de deusto")
plot2 = ggplot(progreso,aes(x=g,y=distancia))+geom_line()+
labs(title = "EvoluciÃ³n de la distancia promedio entre individuos",
subtitle = "Ojo, en este caso la distancia euclÃ­dea no es significativa",
caption = "Universidad de deusto")
grid.arrange(plot1,plot2,ncol=1)
generations = 100000
tournamentsize = 2
probcrossover = 0.9
probmutation  = 0.05
popsize=100
# Paso 8: (para nota) Implemente una funciÃ³n que reciba como argumento el mejor individuo obtenido
# por el algoritmo y las posiciones de los puntos y dibuje las 2 rutas seguidas por los camiones
# Llame a la funciÃ³n al final de la ejecuciÃ³n del algoritmo
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Si todo estÃ¡ bien, el cÃ³digo deberÃ­a funcionar a partir de aquÃ­
# haga las comprobaciones pertienentes para cada operador
# (Si hubiera alguna errata o fallo en el cÃ³digo, que lo puede haber,
# comunÃ­camelo lo antes posible con el fin de solventarlo)
#---------------------------------------------------------------------------
best = c()
bestfitness = Inf
population = initial(popsize,long)
evaluation = apply(population,1,fitness,distancias)
progreso = data.frame(g=numeric(),mejor=numeric(),promedio=numeric(),peor=numeric(),distancia=numeric())
for (g in 1:generations){
indexparents = tournamentselection(evaluation,tournamentsize)
offspring1 = crossover(indexparents,population,probcrossover)
offspring2 = mutation(offspring1,probmutation)
population = offspring2
evaluation = apply(population,1,fitness,distancias)
# Actualizamos el mejor individuo
if (min(evaluation)<bestfitness){
bestfitness=min(evaluation)
best = population[which.min(evaluation),]
}
# Hacemos elitismo
if (bestfitness!=min(evaluation)){
population[1,]=best
}
print(paste("GeneraciÃ³n ",g," Fitness Mejor individuo - ",bestfitness))
print(best)
progreso = rbind(progreso,
data.frame(g=g,mejor=bestfitness,
promedio=mean(evaluation),
peor=max(evaluation),
distancia=mean(as.matrix(dist(population, method = "euclidean")))))
}
# Dibujamos los resultados
plot1 = ggplot(progreso)+
geom_line(aes(x=g,y=mejor),col="green")+
geom_line(aes(x=g,y=promedio),col="blue")+
geom_line(aes(x=g,y=peor),col="red")+
scale_y_log10()+
labs(title = "EvoluciÃ³n de los fitness Mejor, Promedio y Peor",
subtitle = paste("Mejor Individuo Final: ",bestfitness),
caption = "Universidad de deusto")
plot2 = ggplot(progreso,aes(x=g,y=distancia))+geom_line()+
labs(title = "EvoluciÃ³n de la distancia promedio entre individuos",
subtitle = "Ojo, en este caso la distancia euclÃ­dea no es significativa",
caption = "Universidad de deusto")
grid.arrange(plot1,plot2,ncol=1)
generations = 10000
tournamentsize = 2
probcrossover = 1
probmutation  = 0.5
popsize=100
# Paso 8: (para nota) Implemente una funciÃ³n que reciba como argumento el mejor individuo obtenido
# por el algoritmo y las posiciones de los puntos y dibuje las 2 rutas seguidas por los camiones
# Llame a la funciÃ³n al final de la ejecuciÃ³n del algoritmo
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Si todo estÃ¡ bien, el cÃ³digo deberÃ­a funcionar a partir de aquÃ­
# haga las comprobaciones pertienentes para cada operador
# (Si hubiera alguna errata o fallo en el cÃ³digo, que lo puede haber,
# comunÃ­camelo lo antes posible con el fin de solventarlo)
#---------------------------------------------------------------------------
best = c()
bestfitness = Inf
population = initial(popsize,long)
evaluation = apply(population,1,fitness,distancias)
progreso = data.frame(g=numeric(),mejor=numeric(),promedio=numeric(),peor=numeric(),distancia=numeric())
for (g in 1:generations){
indexparents = tournamentselection(evaluation,tournamentsize)
offspring1 = crossover(indexparents,population,probcrossover)
offspring2 = mutation(offspring1,probmutation)
population = offspring2
evaluation = apply(population,1,fitness,distancias)
# Actualizamos el mejor individuo
if (min(evaluation)<bestfitness){
bestfitness=min(evaluation)
best = population[which.min(evaluation),]
}
# Hacemos elitismo
if (bestfitness!=min(evaluation)){
population[1,]=best
}
print(paste("GeneraciÃ³n ",g," Fitness Mejor individuo - ",bestfitness))
print(best)
progreso = rbind(progreso,
data.frame(g=g,mejor=bestfitness,
promedio=mean(evaluation),
peor=max(evaluation),
distancia=mean(as.matrix(dist(population, method = "euclidean")))))
}
# Dibujamos los resultados
plot1 = ggplot(progreso)+
geom_line(aes(x=g,y=mejor),col="green")+
geom_line(aes(x=g,y=promedio),col="blue")+
geom_line(aes(x=g,y=peor),col="red")+
scale_y_log10()+
labs(title = "EvoluciÃ³n de los fitness Mejor, Promedio y Peor",
subtitle = paste("Mejor Individuo Final: ",bestfitness),
caption = "Universidad de deusto")
plot2 = ggplot(progreso,aes(x=g,y=distancia))+geom_line()+
labs(title = "EvoluciÃ³n de la distancia promedio entre individuos",
subtitle = "Ojo, en este caso la distancia euclÃ­dea no es significativa",
caption = "Universidad de deusto")
grid.arrange(plot1,plot2,ncol=1)
generations = 100000
tournamentsize = 2
probcrossover = 1
probmutation  = 0.5
popsize=100
# Paso 8: (para nota) Implemente una funciÃ³n que reciba como argumento el mejor individuo obtenido
# por el algoritmo y las posiciones de los puntos y dibuje las 2 rutas seguidas por los camiones
# Llame a la funciÃ³n al final de la ejecuciÃ³n del algoritmo
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
# Si todo estÃ¡ bien, el cÃ³digo deberÃ­a funcionar a partir de aquÃ­
# haga las comprobaciones pertienentes para cada operador
# (Si hubiera alguna errata o fallo en el cÃ³digo, que lo puede haber,
# comunÃ­camelo lo antes posible con el fin de solventarlo)
#---------------------------------------------------------------------------
best = c()
bestfitness = Inf
population = initial(popsize,long)
evaluation = apply(population,1,fitness,distancias)
progreso = data.frame(g=numeric(),mejor=numeric(),promedio=numeric(),peor=numeric(),distancia=numeric())
for (g in 1:generations){
indexparents = tournamentselection(evaluation,tournamentsize)
offspring1 = crossover(indexparents,population,probcrossover)
offspring2 = mutation(offspring1,probmutation)
population = offspring2
evaluation = apply(population,1,fitness,distancias)
# Actualizamos el mejor individuo
if (min(evaluation)<bestfitness){
bestfitness=min(evaluation)
best = population[which.min(evaluation),]
}
# Hacemos elitismo
if (bestfitness!=min(evaluation)){
population[1,]=best
}
print(paste("GeneraciÃ³n ",g," Fitness Mejor individuo - ",bestfitness))
print(best)
progreso = rbind(progreso,
data.frame(g=g,mejor=bestfitness,
promedio=mean(evaluation),
peor=max(evaluation),
distancia=mean(as.matrix(dist(population, method = "euclidean")))))
}
# Dibujamos los resultados
plot1 = ggplot(progreso)+
geom_line(aes(x=g,y=mejor),col="green")+
geom_line(aes(x=g,y=promedio),col="blue")+
geom_line(aes(x=g,y=peor),col="red")+
scale_y_log10()+
labs(title = "EvoluciÃ³n de los fitness Mejor, Promedio y Peor",
subtitle = paste("Mejor Individuo Final: ",bestfitness),
caption = "Universidad de deusto")
plot2 = ggplot(progreso,aes(x=g,y=distancia))+geom_line()+
labs(title = "EvoluciÃ³n de la distancia promedio entre individuos",
subtitle = "Ojo, en este caso la distancia euclÃ­dea no es significativa",
caption = "Universidad de deusto")
grid.arrange(plot1,plot2,ncol=1)
