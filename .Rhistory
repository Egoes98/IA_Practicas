num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
#REVISAR!!!!!!!!!!!!!!!!!! De 0 a 100 auqnue no sea maximo real
range.data <- matrix(c(0,100, 0, 40, 0, 100), nrow=2)
# Paso 6, defina el tipo de defuzificaciÃ³n, tnorma y tconorma, e implicaciÃ³n, asÃ­ como el tipo de modelo
# --> type.defuz = "COG"
# --> type.tnorm = "MIN"
# --> type.snorm = "MAX"
# --> type.implication.func = "MIN"
# --> type.model <- "MAMDANI"
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
# Paso 7, cree una variable "newdata" Ãºnicamente con las columnas que utilizarÃ¡ su sistema
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = datos %>% select(TSP,MPG)
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
# Paso 9, defina los nombres de las etiquetas de salida y sus funciones, de la misma manera que en los pasos 1,2,3,4
num.fvaloutput = matrix(c(5), nrow = 1)
varoutput.1 = c("e1", "e2", "e3")
names.varoutput = c(varoutput.1)
#!!!!!!!!!!! TERMINAR
varout.mf = matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
rule = matrix( c("Mal tirador", "and", "Poco tiempo jugado","->", "e1",
"Buen tirador", "and", "Poco tiempo jugado","->", "e2",
"Mal tirador", "and", "Mucho tiempo jugado","->", "e3"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
TSPBajo = c(2,0,30,40,NA)
TSPMedio = c(4,30,40,56,75)
TSPALTO = c(3,56,75,100,NA)
#Conjuntos difusos MPG
MPGBajo = c(2,0,10,20,NA)
MPGMedio = c(4,10,20,25,30)
MPGAlto = c(3,25,30,40,NA)
# Paso 2, pegar todas las etiquetas por columnas y asignar a una variable
# --> varinp.mf = cbind(etiqueta1,etiqueta2,etiqueta3...)
varinp.mf = cbind(TSPBajo,TSPMedio,TSPALTO,MPGBajo,MPGMedio,MPGAlto)
# Paso 3, definir una matriz con el nÃºmero de etiquetas de cada entrada
# --> num.fvalinput = matrix(c(numeroetiquetasentrada1,numeroetiquetasentrada2), nrow=1)
num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
#REVISAR!!!!!!!!!!!!!!!!!! De 0 a 100 auqnue no sea maximo real
range.data <- matrix(c(0,100, 0, 40, 0, 100), nrow=2)
# Paso 6, defina el tipo de defuzificaciÃ³n, tnorma y tconorma, e implicaciÃ³n, asÃ­ como el tipo de modelo
# --> type.defuz = "COG"
# --> type.tnorm = "MIN"
# --> type.snorm = "MAX"
# --> type.implication.func = "MIN"
# --> type.model <- "MAMDANI"
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
# Paso 7, cree una variable "newdata" Ãºnicamente con las columnas que utilizarÃ¡ su sistema
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = datos %>% select(TSP,MPG)
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
# Paso 9, defina los nombres de las etiquetas de salida y sus funciones, de la misma manera que en los pasos 1,2,3,4
num.fvaloutput = matrix(c(5), nrow = 1)
varoutput.1 = c("e1", "e2", "e3")
names.varoutput = c(varoutput.1)
#!!!!!!!!!!! TERMINAR
varout.mf = matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
rule = matrix( c("Mal tirador", "and", "Poco tiempo jugado","->", "e1",
"Buen tirador", "and", "Poco tiempo jugado","->", "e2",
"Mal tirador", "and", "Mucho tiempo jugado","->", "e3"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
# Nombre: Egoitz Aranzabal Calvo
# Entrega: 2
# Fecha:
##---------------------------------------------------------------------------
# Tiempo dedicado a la entrega:
# Dificultades encontradas y manera de resolverlas:
##---------------------------------------------------------------------------
# 1. AsegÃºrese de incluir, junto a esta plantilla, cualquier fichero necesario
#    para su ejecuciÃ³n, incluidos datasets
# 2. Si utiliza una funciÃ³n de un determinado paquete, no olvide incluir la
#    correspondiente llamada a la funciÃ³n "library()"
# 3. No olvide comentar el cÃ³digo, en especial aquellos comandos no-triviales
#    (recuerda que parte de la calificaciÃ³n depende de la limpieza del cÃ³digo)
#---------------------------------------------------------------------------.
rm(list = ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
library(frbs)
library(ggplot2)
# (incluya aquÃ­ cualquier librerÃ­a adicional)
library(tidyverse)
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
######################## Parte 1 ###########################################
#--------------------------------------------------------------------------.
# Descarge y lea los datos que puede encontrar en el siguiente link:
# https://www.kaggle.com/jacobbaruch/basketball-players-stats-per-season-49-leagues
# Lea los datos en R
datos = read.csv("datos/players_stats_by_season_full_details.csv")
resultados = datos %>% select(Player,Season,weight_kg,height_cm)
# AÃ±ada una columna llamada altocrisp con valores 0 o 1 (numÃ©ricos) segÃºn si la
# altura del juegador es menor o mayor que 190cm
resultados$altocrisp = ifelse(resultados$height_cm>190,1,0)
# Defina, como un vector de 4 elementos un conjunto difuso llamado alto
# (como considere deberÃ­a ser)
# --> alto = c(..., ..., ..., ...)
alto = c(190,210,230,2300)
# Cree una funciÃ³n llamada trapMF que reciba un nÃºmero y un conjunto difuso y
# devuelva el valor de pertenencia del nÃºmero al conjunto definido
# --> trapMF = function(valor,conjunto){....}
trapMF= function(valor, conjunto){
ifelse(between(valor,conjunto[1], conjunto[2]),((valor-conjunto[1])/(conjunto[2]-conjunto[1])),
ifelse(between(valor,conjunto[2], conjunto[3]),1,
ifelse(between(valor,conjunto[3], conjunto[4]),((conjunto[4]-valor)/(conjunto[4]-conjunto[3])),0)))
}
# AÃ±ada una columna llamada altofuzzy, resultado de aplicar la funciÃ³n trapMF sobre los elementos de la columna height y el conjunto alto
# --> nombredeldataframe$altofuzzy = apply(data.frame(nombredeldataframe$height), 1, FUN=function(x) trapMF(x,alto))
resultados$altofuzzy = apply(data.frame(resultados$height_cm), 1, FUN=function(x) trapMF(x,alto))
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altocrisp
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altofuzzy
# En ambos casos, utilize el valor de altura para colorear los puntos
# --> Utilize la librerÃ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=altocrisp))+geom_point()
ggplot(resultados,aes(x=height_cm,y=altofuzzy))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 2 ###########################################
#--------------------------------------------------------------------------.
# De la misma manera que en la primera parte, cree un conjunto llamado "pesado",
# para el peso de un jugador
# --> pesado = c(..., ..., ..., ...)
pesado = c(95,120,180,180)
# AÃ±ada una columna llamada pesadofuzzy, resultado de aplicar la funciÃ³n trapMF sobre los elementos de la columna points_per_minute y el conjunto bueno
# --> nombredeldataframe$pesadofuzzy = apply(..., 1, FUN=function(x) trapMF(x,pesado))
resultados$pesadofuzzy = apply(data.frame(resultados$weight_kg),1,function(x) trapMF(x,pesado))
# Genere una columna llamada altoypesado resultado de la tnorma mÃ­nimo sobre las columnas altofuzzy y pesadofuzzy
# --> nombredeldataframe$altoypesado = ...
resultados$altoypesado = apply(data.frame(resultados$altofuzzy, resultados$pesadofuzzy), 1, max)
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X, su peso en el eje Y, y utilize para dar color el valor de la columna altoypesado, generada
# --> Utilize la librerÃ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=weight_kg,color=altoypesado))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 3 ###########################################
#--------------------------------------------------------------------------.
# Implemente un sistema difuso que dÃ© una valoraciÃ³n entre 0 y 100 de los jugadores de baloncesto
# a partir de las caracterÃ­sticas del fichero de datos
# Criterio de valoraciÃ³n libre
# Requisitos bÃ¡sicos
# Utilizar al menos 2 de las variables y codificar cada una de ellas con al menos 3 conjuntos difusos
# Incluir al menos 5 reglas difusas
# AÃ±ada el resultado de la ejecuciÃ³n del sistema como una nueva columna a los datos y genere un dibujo
# Pista1: En la ayuda de la funciÃ³n "frbs.gen" tenÃ©is un ejemplo de creaciÃ³n de un sistema difuso
# Pista2: Os dejo aquÃ­ un desglose de los pasos a dar, con alguna indicaciÃ³n
# Consejo: explore la posibilidad de crear nuevas columnas en funciÃ³n de los datos numÃ©ricos que hay en la tabla
#  - % de acierto de 3 puntos
#  - Puntos/partido
#  - Minutos jugados/partido
#  (...)
#Cambio los NA por 0 para evitar problemas en la parte 3 a la hora de hacer el sistema
datos[is.na(datos)] = 0
#True Shooting Percentage
tsp = function(PTS,FGA,FTA){
return ((PTS/(2*(FGA+(0.44*FTA))))*100)
}
datos$TSP = apply(data.frame(datos$PTS, datos$FGA, datos$FTA), 1,function(x) tsp(x[1],x[2],x[3]))
#Minutes per game
mpg = function(MIN,GP){
return (MIN/GP)
}
datos$MPG = apply(data.frame(datos$MIN, datos$GP), 1, function(x) mpg(x[1],x[2]))
# Paso 1, definir todos los conjuntos difusos a usar como vectores de 5 elementos
# --> etiqueta1 = c(valor,xxx, xxx, xxx, xxx)
# *nota, valor serÃ¡ 2, 3, 4, dependiendo si es una etiqueta "izquierda"(2), "central"(4), o "derecha"(3)
# *para etiquetas "izquierdas", c(2,b,c,d,NA)
# *para etiquetas "centrales", c(4,a,b,c,d)
# *para etiquetas "derechas", c(3,a,b,c,NA)
# *a,b,c,d representan los puntos de una etiqueta trapezoidal
#Conjuntos difusos TSP
TSPBajo = c(2,0,30,40,NA)
TSPMedio = c(4,30,40,56,75)
TSPALTO = c(3,56,75,100,NA)
#Conjuntos difusos MPG
MPGBajo = c(2,0,10,20,NA)
MPGMedio = c(4,10,20,25,30)
MPGAlto = c(3,25,30,40,NA)
# Paso 2, pegar todas las etiquetas por columnas y asignar a una variable
# --> varinp.mf = cbind(etiqueta1,etiqueta2,etiqueta3...)
varinp.mf = cbind(TSPBajo,TSPMedio,TSPALTO,MPGBajo,MPGMedio,MPGAlto)
# Paso 3, definir una matriz con el nÃºmero de etiquetas de cada entrada
# --> num.fvalinput = matrix(c(numeroetiquetasentrada1,numeroetiquetasentrada2), nrow=1)
num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
#REVISAR!!!!!!!!!!!!!!!!!! De 0 a 100 auqnue no sea maximo real
range.data <- matrix(c(0,100, 0, 40, 0, 100), nrow=2)
# Paso 6, defina el tipo de defuzificaciÃ³n, tnorma y tconorma, e implicaciÃ³n, asÃ­ como el tipo de modelo
# --> type.defuz = "COG"
# --> type.tnorm = "MIN"
# --> type.snorm = "MAX"
# --> type.implication.func = "MIN"
# --> type.model <- "MAMDANI"
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
# Paso 7, cree una variable "newdata" Ãºnicamente con las columnas que utilizarÃ¡ su sistema
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = datos %>% select(TSP,MPG)
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
# Paso 9, defina los nombres de las etiquetas de salida y sus funciones, de la misma manera que en los pasos 1,2,3,4
num.fvaloutput = matrix(c(5), nrow = 1)
varoutput.1 = c("MVP", "Buen jugador", "Mal jugador")
names.varoutput = c(varoutput.1)
#!!!!!!!!!!! TERMINAR
varout.mf = matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Buen jugador",
"Mal tirador", "and", "Poco tiempo jugado","->", "Mal jugador"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
# Paso 12, aÃ±ada el resultado como una nueva columna y dibuje las dos variables usadas, dando color con el resultado obtenido
# --> newdata$calidad = evaluacion
# --> ggplot(...col=calidad...)+...
newdata$calidad = evaluacion
ggplot()
# Nombre: Egoitz Aranzabal Calvo
# Entrega: 2
# Fecha:
##---------------------------------------------------------------------------
# Tiempo dedicado a la entrega:
# Dificultades encontradas y manera de resolverlas:
##---------------------------------------------------------------------------
# 1. AsegÃºrese de incluir, junto a esta plantilla, cualquier fichero necesario
#    para su ejecuciÃ³n, incluidos datasets
# 2. Si utiliza una funciÃ³n de un determinado paquete, no olvide incluir la
#    correspondiente llamada a la funciÃ³n "library()"
# 3. No olvide comentar el cÃ³digo, en especial aquellos comandos no-triviales
#    (recuerda que parte de la calificaciÃ³n depende de la limpieza del cÃ³digo)
#---------------------------------------------------------------------------.
rm(list = ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
library(frbs)
library(ggplot2)
# (incluya aquÃ­ cualquier librerÃ­a adicional)
library(tidyverse)
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
######################## Parte 1 ###########################################
#--------------------------------------------------------------------------.
# Descarge y lea los datos que puede encontrar en el siguiente link:
# https://www.kaggle.com/jacobbaruch/basketball-players-stats-per-season-49-leagues
# Lea los datos en R
datos = read.csv("datos/players_stats_by_season_full_details.csv")
resultados = datos %>% select(Player,Season,weight_kg,height_cm)
# AÃ±ada una columna llamada altocrisp con valores 0 o 1 (numÃ©ricos) segÃºn si la
# altura del juegador es menor o mayor que 190cm
resultados$altocrisp = ifelse(resultados$height_cm>190,1,0)
# Defina, como un vector de 4 elementos un conjunto difuso llamado alto
# (como considere deberÃ­a ser)
# --> alto = c(..., ..., ..., ...)
alto = c(190,210,230,2300)
# Cree una funciÃ³n llamada trapMF que reciba un nÃºmero y un conjunto difuso y
# devuelva el valor de pertenencia del nÃºmero al conjunto definido
# --> trapMF = function(valor,conjunto){....}
trapMF= function(valor, conjunto){
ifelse(between(valor,conjunto[1], conjunto[2]),((valor-conjunto[1])/(conjunto[2]-conjunto[1])),
ifelse(between(valor,conjunto[2], conjunto[3]),1,
ifelse(between(valor,conjunto[3], conjunto[4]),((conjunto[4]-valor)/(conjunto[4]-conjunto[3])),0)))
}
# AÃ±ada una columna llamada altofuzzy, resultado de aplicar la funciÃ³n trapMF sobre los elementos de la columna height y el conjunto alto
# --> nombredeldataframe$altofuzzy = apply(data.frame(nombredeldataframe$height), 1, FUN=function(x) trapMF(x,alto))
resultados$altofuzzy = apply(data.frame(resultados$height_cm), 1, FUN=function(x) trapMF(x,alto))
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altocrisp
# Haga un dibujo que muestre la altura del jugador en el eje X y el valor de altofuzzy
# En ambos casos, utilize el valor de altura para colorear los puntos
# --> Utilize la librerÃ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=altocrisp))+geom_point()
ggplot(resultados,aes(x=height_cm,y=altofuzzy))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 2 ###########################################
#--------------------------------------------------------------------------.
# De la misma manera que en la primera parte, cree un conjunto llamado "pesado",
# para el peso de un jugador
# --> pesado = c(..., ..., ..., ...)
pesado = c(95,120,180,180)
# AÃ±ada una columna llamada pesadofuzzy, resultado de aplicar la funciÃ³n trapMF sobre los elementos de la columna points_per_minute y el conjunto bueno
# --> nombredeldataframe$pesadofuzzy = apply(..., 1, FUN=function(x) trapMF(x,pesado))
resultados$pesadofuzzy = apply(data.frame(resultados$weight_kg),1,function(x) trapMF(x,pesado))
# Genere una columna llamada altoypesado resultado de la tnorma mÃ­nimo sobre las columnas altofuzzy y pesadofuzzy
# --> nombredeldataframe$altoypesado = ...
resultados$altoypesado = apply(data.frame(resultados$altofuzzy, resultados$pesadofuzzy), 1, max)
# Dibuje
# Haga un dibujo que muestre la altura del jugador en el eje X, su peso en el eje Y, y utilize para dar color el valor de la columna altoypesado, generada
# --> Utilize la librerÃ­a ggplop2
ggplot(resultados,aes(x=height_cm,y=weight_kg,color=altoypesado))+geom_point()
#---------------------------------------------------------------------------
######################## Parte 3 ###########################################
#--------------------------------------------------------------------------.
# Implemente un sistema difuso que dÃ© una valoraciÃ³n entre 0 y 100 de los jugadores de baloncesto
# a partir de las caracterÃ­sticas del fichero de datos
# Criterio de valoraciÃ³n libre
# Requisitos bÃ¡sicos
# Utilizar al menos 2 de las variables y codificar cada una de ellas con al menos 3 conjuntos difusos
# Incluir al menos 5 reglas difusas
# AÃ±ada el resultado de la ejecuciÃ³n del sistema como una nueva columna a los datos y genere un dibujo
# Pista1: En la ayuda de la funciÃ³n "frbs.gen" tenÃ©is un ejemplo de creaciÃ³n de un sistema difuso
# Pista2: Os dejo aquÃ­ un desglose de los pasos a dar, con alguna indicaciÃ³n
# Consejo: explore la posibilidad de crear nuevas columnas en funciÃ³n de los datos numÃ©ricos que hay en la tabla
#  - % de acierto de 3 puntos
#  - Puntos/partido
#  - Minutos jugados/partido
#  (...)
#Cambio los NA por 0 para evitar problemas en la parte 3 a la hora de hacer el sistema
datos[is.na(datos)] = 0
#True Shooting Percentage
tsp = function(PTS,FGA,FTA){
return ((PTS/(2*(FGA+(0.44*FTA))))*100)
}
datos$TSP = apply(data.frame(datos$PTS, datos$FGA, datos$FTA), 1,function(x) tsp(x[1],x[2],x[3]))
#Minutes per game
mpg = function(MIN,GP){
return (MIN/GP)
}
datos$MPG = apply(data.frame(datos$MIN, datos$GP), 1, function(x) mpg(x[1],x[2]))
# Paso 1, definir todos los conjuntos difusos a usar como vectores de 5 elementos
# --> etiqueta1 = c(valor,xxx, xxx, xxx, xxx)
# *nota, valor serÃ¡ 2, 3, 4, dependiendo si es una etiqueta "izquierda"(2), "central"(4), o "derecha"(3)
# *para etiquetas "izquierdas", c(2,b,c,d,NA)
# *para etiquetas "centrales", c(4,a,b,c,d)
# *para etiquetas "derechas", c(3,a,b,c,NA)
# *a,b,c,d representan los puntos de una etiqueta trapezoidal
#Conjuntos difusos TSP
TSPBajo = c(2,0,30,40,NA)
TSPMedio = c(4,30,40,56,75)
TSPALTO = c(3,56,75,100,NA)
#Conjuntos difusos MPG
MPGBajo = c(2,0,10,20,NA)
MPGMedio = c(4,10,20,25,30)
MPGAlto = c(3,25,30,40,NA)
# Paso 2, pegar todas las etiquetas por columnas y asignar a una variable
# --> varinp.mf = cbind(etiqueta1,etiqueta2,etiqueta3...)
varinp.mf = cbind(TSPBajo,TSPMedio,TSPALTO,MPGBajo,MPGMedio,MPGAlto)
# Paso 3, definir una matriz con el nÃºmero de etiquetas de cada entrada
# --> num.fvalinput = matrix(c(numeroetiquetasentrada1,numeroetiquetasentrada2), nrow=1)
num.fvalinput = matrix(c(3,3), nrow=1)
# Paso 4, dele nombre a cada etiqueta en un vector
# --> names.varinput = c("nombre1", "nombre2", "nombre3", "nombre4", ...)
varinput.1 <- c("Mal tirador", "Tirador medio", "Buen tirador")
varinput.2 <- c("Poco tiempo jugado", "Tiempo jugado medio", "Mucho tiempo jugado")
names.varinput <- c(varinput.1, varinput.2)
# Paso 5, defina los rangos de las variables de entrada y de la salida
# --> range.data = matrix(c(minimoentrada1, maximoentrada1, minimoentrada2, maximoentrada2, 0, 100), nrow = 2)
#REVISAR!!!!!!!!!!!!!!!!!! De 0 a 100 auqnue no sea maximo real
range.data <- matrix(c(0,100, 0, 40, 0, 100), nrow=2)
# Paso 6, defina el tipo de defuzificaciÃ³n, tnorma y tconorma, e implicaciÃ³n, asÃ­ como el tipo de modelo
# --> type.defuz = "COG"
# --> type.tnorm = "MIN"
# --> type.snorm = "MAX"
# --> type.implication.func = "MIN"
# --> type.model <- "MAMDANI"
type.defuz <- "WAM"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func = "MIN"
type.model <- "MAMDANI"
name = "Sistema-difuso"
# Paso 7, cree una variable "newdata" Ãºnicamente con las columnas que utilizarÃ¡ su sistema
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = datos %>% select(TSP,MPG)
# Paso 8, Cree un vector con los nombres de las variables
# colnames.var = c("Nombreentrada1", "Nombreentrada2", "Nombresalida")
colnames.var = c("TSP", "MPG", "output1")
# Paso 9, defina los nombres de las etiquetas de salida y sus funciones, de la misma manera que en los pasos 1,2,3,4
#num.fvaloutput = matrix(c(5), nrow = 1)
num.fvaloutput = matrix(c(3), nrow = 1)
#varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio", "Jugador de bajo nivel", "Mal jugador")
varoutput.1 = c("MVP", "Jugador de nivel alto", "Jugador de nivel medio")
names.varoutput = c(varoutput.1)
varout.mf = matrix(c(2, 0, 10, 20, NA, 4, 10, 20, 40, 60, 3, 40, 60, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
#rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
#                    "Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
#                    "Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio",
#                    "Tirador medio", "and", "Poco tiempo jugado","->", "Jugador de bajo nivel",
#                   "Mal tirador", "and", "Poco tiempo jugado","->", "Mal jugador"),
#                  nrow = 5, byrow = TRUE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
varout.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
# Paso 10, Defina una matriz con las reglas, utilizando el siguiente formato (ejemplo para 1 regla)
# --> rule = matrix( c("nombreetiqueta1", "and", "nombreetiqueta2","->", "etiquetadesalida"), nrow = 1, byrow = TRUE)
#rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
#                    "Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
#                    "Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio",
#                    "Tirador medio", "and", "Poco tiempo jugado","->", "Jugador de bajo nivel",
#                   "Mal tirador", "and", "Poco tiempo jugado","->", "Mal jugador"),
#                  nrow = 5, byrow = TRUE)
rule = matrix( c("Buen tirador", "and", "Mucho tiempo jugado","->", "MVP",
"Tirador medio", "and", "Mucho tiempo jugado","->", "Jugador de nivel alto",
"Tirador medio", "and", "Tiempo jugado medio","->", "Jugador de nivel medio"),
nrow = 3, byrow = TRUE)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
#REVISAR!!!!!!!!!!!!!!!!!!
#newdata = matrix(c(datos$MPG,datos$TSP), nrow = 2)
newdata = cbind(datos$TSP, datos$MPG)
# Paso 11, utilice la funciÃ³n frbs.gen() para crear el sistema difuso, y la funciÃ³n predict para ponerlo a prueba sobre los datos
# --> sistema = frbs.gen(...)
# --> evaluacion = predict(sistema, newdata)$predicted.val
sistema = frbs.gen(range.data, num.fvalinput, names.varinput,
num.fvaloutput, varout.mf, names.varoutput, rule,
varinp.mf, type.model, type.defuz, type.tnorm,
type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)
plotMF(sistema)
evaluacion = predict(sistema, newdata)$predicted.val
View(sistema)
View(newdata)
View(newdata)
evaluacion = predict(sistema, newdata)$predicted.val
